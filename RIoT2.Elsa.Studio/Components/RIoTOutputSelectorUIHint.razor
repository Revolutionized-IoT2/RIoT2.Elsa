@inherits StudioComponentBase
@{
    var inputDescriptor = EditorContext.InputDescriptor;
    var displayName = inputDescriptor.DisplayName;
    var description = inputDescriptor.Description;
}

@using RIoT2.Elsa.Studio.Models
@using RIoT2.Elsa.Studio.UIProviders
@using System.Globalization
@using System.Reflection
@using System.Text.Json.Nodes
@using global::Elsa.Api.Client.Resources.ActivityDescriptors.Models
@using global::Elsa.Api.Client.Resources.Scripting.Models
@using global::Elsa.Api.Client.Shared.UIHints.CodeEditor
@using global::Elsa.Studio.Components
@using global::Elsa.Studio.Models
@using System.Text.Json;

<MudAutocomplete T="RIoTTemplateItem"
                ValueChanged="autoCompleteValueChanged"
                Value="@_selectedTemplate"
                ToStringFunc="@(e => string.IsNullOrEmpty(e.Name) ? "unknown" : e.Name)"
                SearchFunc="@Search"
                Label="@displayName"
                Margin="@_margin"
                Dense="@_dense"
                Disabled="@_disabled"
                ReadOnly="@_readonly"
                Placeholder="@(_placeholder ? "Placeholder" : null)"
                HelperText="@(_helperText ? "Helper Text" : null)"
                HelperTextOnFocus="_helperTextOnFocus"
                Clearable="_clearable"
                Modal="_modal" >
            <NoItemsTemplate>
                <MudText Align="Align.Center" Class="px-4 py-1">
                    No Outputs found
                </MudText>
            </NoItemsTemplate>
            <ItemTemplate Context="e">
                <MudText>
                    @e.Name
                </MudText>
                <MudItem xs="12" md="12">
                    <MudChip T="string" Color="Color.Primary" Label="true" Size="Size.Small">@e.Node</MudChip>
                    <MudChip T="string" Color="Color.Secondary" Label="true" Size="Size.Small">@e.Device</MudChip>
                    <MudChip T="string" Color="Color.Tertiary" Label="true" Size="Size.Small">@e.Type.ToString()</MudChip>
                </MudItem>
            </ItemTemplate>
            <ItemSelectedTemplate Context="e">
                <MudText>
                    @e.Name
                </MudText>
                <MudItem xs="12" md="12">
                    <MudChip T="string" Color="Color.Primary" Label="true" Size="Size.Small">@e.Node</MudChip>
                    <MudChip T="string" Color="Color.Secondary" Label="true" Size="Size.Small">@e.Device</MudChip>
                    <MudChip T="string" Color="Color.Tertiary" Label="true" Size="Size.Small">@e.Type.ToString()</MudChip>
                </MudItem>
            </ItemSelectedTemplate>
</MudAutocomplete>

@if (_selectedTemplate !=  default)
{ 
    @switch (_selectedTemplate?.Type)
    {
        case Core.ValueType.Boolean:
            <p>TODO - bool</p>
            break;
        case Core.ValueType.Text:
            <p>TODO - text</p>
            break;
        case Core.ValueType.Number:
            <p>TODO - number</p>
            break;
        case Core.ValueType.Entity:
            <RIoTEditor @ref="editor" EditorContext="@EditorContext" OnChanged=@editorValueChanged />
            break;
        case Core.ValueType.TextArray:
            <p>TODO - text arr</p>
            break;
    }
}

@code {
    [Parameter]
    public DisplayInputEditorContext EditorContext { get; set; } = default!;
    RIoTEditor editor = default!;

    private RIoTTemplateItem _selectedTemplate = default!;
    public Margin _margin = Margin.None;
    public bool _dense = false;
    public bool _disabled = false;
    public bool _readonly = false;
    public bool _placeholder = false;
    public bool _helperText = false;
    public bool _helperTextOnFocus = false;
    public bool _clearable = false;
    public bool _modal = true;
    public List<RIoTTemplateItem> _items = new();

    protected override void OnInitialized()
    {

        var currentValue = EditorContext.GetLiteralValueOrDefault();

        if (currentValue != null)
        {
            try
            {
                _selectedTemplate = JsonSerializer.Deserialize<RIoTTemplateItem>(currentValue) ?? default!;
                Console.WriteLine("current value: " + currentValue);
                selectedItemChanged(false);
            }
            catch (Exception x)
            {
                Console.WriteLine("Failed to deserialize current value: " + x.Message);
                Console.WriteLine("Value: " + currentValue);
            }
        }

        var selectList = EditorContext.InputDescriptor.GetRIoTTemplateList();
        if (selectList != null && selectList.Items != null)
            _items = selectList.Items.OrderBy(x => x.Device).ThenBy(x => x.Name).ToList();
    }

    private string toCamelCase(string text)
    {
        TextInfo _textInfo = CultureInfo.InvariantCulture.TextInfo;
        char[] _camelCase = _textInfo.ToTitleCase(text).Replace(" ", "").ToCharArray();

        _camelCase[0] = char.ToLower(_camelCase[0]);
        return new string(_camelCase);
    }

    private string createDefaultValue(object? obj, string name)
    {
        string propStr = "";
        string json = "";
        string camelName = toCamelCase(name);
        if (obj != null)
        {
            json = JsonSerializer.Serialize(obj);
            JsonObject jobj = JsonNode.Parse(json)!.AsObject();
            string[] propertyNames = jobj.Select(p => p.Key).ToArray();
            foreach (string prop in propertyNames)
            {
                string? valStr = jobj[prop]?.ToString();
                if (jobj[prop]?.GetValueKind() == JsonValueKind.String)
                    valStr = @""""+valStr+@"""";

                propStr += "\n" + camelName + "." + prop + " = " + valStr + ";";
            }
        }

        var txt = "var " + camelName + " = " + json + ";";
        txt += propStr;
        txt += "\nreturn " + toCamelCase(name) + ";";
        return txt;
    }

    private Task SaveChangesAsync()
    {
        if (_selectedTemplate != default)
        {
            var value = JsonSerializer.Serialize(_selectedTemplate);
            //Console.WriteLine("Save: " + value);
            var expression = Expression.CreateLiteral(value);
            return EditorContext.UpdateExpressionAsync(expression);
        }

        return Task.CompletedTask;
    }

    private async void selectedItemChanged(bool save = true)
    {
        await Task.Delay(20); //added small delay to make sure the editor is rendered before setting the value, otherwise it can cause issues with the editor not updating
        switch (_selectedTemplate.Type)
        {
            case Core.ValueType.Entity:
                try
                {
                    editor.SetValue(_selectedTemplate.Value ?? "");
                }
                catch (Exception x)
                {
                    Console.WriteLine("VIRHE: " + x.Message);
                }
                break;
        }

        if (save)
            await SaveChangesAsync();
    }

    private void autoCompleteValueChanged(RIoTTemplateItem value)
    {
        _selectedTemplate = value;
        if (_selectedTemplate.Type == Core.ValueType.Entity && string.IsNullOrEmpty(_selectedTemplate.Value))
            _selectedTemplate.Value = createDefaultValue(_selectedTemplate.Model ?? "", _selectedTemplate.Name);

        selectedItemChanged();
    }

    private async void editorValueChanged(string value)
    {
        _selectedTemplate.Value = value;
        Console.WriteLine("VALUE: " + value);
        await SaveChangesAsync();
    }

    public async Task<IEnumerable<RIoTTemplateItem>> Search(string value, CancellationToken token) => 
        await Task.Run(() =>
        {
            if (string.IsNullOrEmpty(value))
                return _items;

            return _items.Where(x => x.Name.Contains(value, StringComparison.InvariantCultureIgnoreCase));
        });
}